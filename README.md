# CMPT225
Software Development:
1. Convert specifications into high-level design, apply software engineering and design concepts, and express OO design in UML class diagrams
write C++ code
2. Encapsulate methods and variables for an ADT into a C++ class
3. Develop, compile and test their programs using the standard unix/linux tool set (e.g., make/g++)
4. Differentiate between memory declared globally, on the stack, and on the heap
5. Implement functions/algorithms that pass pointers as parameters, perform pointer arithmetic and manipulate pointers
6. Manage memory in C++, allocate and free arrays and individual elements in heap
design and use test cases

Abstract Data Types (ADTs):
1. define "abstract data type" and "data structure" and differentiate between the two
2. define the following ADTs in terms of their data and their operations (their public interface): stack, queue, priority queue
3. give examples of real-life applications of the above ADTs
4. define the following data structures, and demonstrate, simulate, and trace operations on them:
5. static array
6. dynamic array
7. circular array
8. linked list (singly/doubly headed, singly/doubly linked, etc...)
9. binary heap [balanced] binary search tree (for example: AVL and B-trees), [chained / open addressed] hash table
10. discuss tradeoffs in designing hash functions and describe collisions

Recursion:
1. describe tradeoffs between recursive and iterative solutions to problems
2. write recursive solutions to non-trivial problems, such as binary search tree traversals and recursive sorts
write recursive definitions of binary heap and BST
3. Complexity Analysis:
4. analyze the best, worst, and average case running time of various ADT operations implemented by various data structures
5. analyze the best, worst, and average case running time of basic sorting algorithms above
6. describe alternatives for measuring the performance of an algorithm implementation such as empirical measurement of running time, by counting the elementary operations and/or O notation

External Storage:
1. perform operations on data that are too large to fit in memory, e.g.:external mergesort, index files and data files
